# R√©capitulatif D√©veloppement - 26 Octobre 2025

## üéØ Objectif de la Session

Impl√©menter le support complet de l'int√©gration WeWeb avec:
1. Gestion de `item_id: null` envoy√© par WeWeb
2. Support de `category_id` et `subcategory_id` en plus des noms
3. Architecture multilingue avec utilisation d'IDs pour les relations

## ‚úÖ Travaux R√©alis√©s

### 1. Migrations Base de Donn√©es

#### Migration 1: `20251026000012_handle_null_item_id.sql`
**Objectif**: G√©rer les item_id NULL de WeWeb

**Changements**:
- Fonction `validate_and_calculate_item()` accepte maintenant `item_id` en TEXT ou NULL
- Si NULL ou vide ‚Üí g√©n√©ration automatique d'un UUID via `gen_random_uuid()`
- Retour du `generated_item_id` dans la r√©ponse JSON pour que WeWeb puisse le r√©cup√©rer

```sql
-- Auto-g√©n√©ration UUID si item_id NULL
IF v_item_id IS NULL OR v_item_id = '' THEN
  v_item_id_uuid := gen_random_uuid();
ELSE
  v_item_id_uuid := gen_random_uuid();
END IF;

-- Retour dans la r√©ponse
RETURN jsonb_build_object(
  'success', true,
  'generated_item_id', v_item_id_uuid,  -- NOUVEAU
  ...
);
```

#### Migration 2: `20251026000013_handle_category_ids.sql`
**Objectif**: Accepter category_id/subcategory_id de WeWeb

**Changements**:
- Ajout de param√®tres `v_category_id` et `v_subcategory_id` dans la fonction
- Lookup automatique des noms depuis les tables `odl_product_categories` et `odl_product_subcategories`
- Support des product ET service categories

```sql
-- Lookup depuis ID vers nom
IF v_subcategory_id IS NOT NULL THEN
  SELECT s.name, c.name INTO v_subcategory_name, v_category_name
  FROM odl_product_subcategories s
  JOIN odl_product_categories c ON s.category_id = c.category_id
  WHERE s.subcategory_id = v_subcategory_id AND s.is_active = true;
END IF;
```

#### Migration 3: `20251026000014_refactor_to_category_ids.sql` ‚≠ê MAJEUR
**Objectif**: Refactorisation compl√®te pour architecture multilingue

**Changements Structurels**:

1. **Ajout colonnes ID dans `odl_rules`**:
```sql
ALTER TABLE odl_rules
  ADD COLUMN IF NOT EXISTS category_id TEXT,
  ADD COLUMN IF NOT EXISTS subcategory_id TEXT;
```

2. **Ajout colonnes ID dans `offer_item_calculated_costs`**:
```sql
ALTER TABLE offer_item_calculated_costs
  ADD COLUMN IF NOT EXISTS category_id TEXT,
  ADD COLUMN IF NOT EXISTS subcategory_id TEXT;
```

3. **Matching des r√®gles m√©tier par ID** (plus par nom):
```sql
SELECT * INTO v_rule
FROM odl_rules
WHERE is_active = true
  AND (
    (scope = 'subcategory' AND category_id = v_category_id AND subcategory_id = v_subcategory_id)
    OR (scope = 'category' AND category_id = v_category_id AND subcategory_id IS NULL)
    OR (scope = 'global' AND category_id IS NULL AND subcategory_id IS NULL)
  )
ORDER BY CASE scope WHEN 'subcategory' THEN 1 WHEN 'category' THEN 2 ELSE 3 END
LIMIT 1;
```

4. **Lookup droits de douane par subcategory_id** (table d√©j√† en place):
```sql
SELECT duty_percent INTO v_customs_duty_rate
FROM odeal_customs_duty_rates
WHERE subcategory_id = v_subcategory_id
LIMIT 1;
```

5. **Backward compatibility totale**:
- Accepte SOIT category_id/subcategory_id SOIT category_name/subcategory_name
- Conversion bidirectionnelle ID ‚Üî nom
- Stockage des deux (ID pour relations, nom pour affichage)

**Status**: ‚úÖ Appliqu√©e en production avec succ√®s

### 2. Modifications API Route `/api/validate-item`

**Fichier**: `applications/odl-tools/app/api/validate-item/route.ts`

**Interface mise √† jour**:
```typescript
interface ValidateItemRequest {
  // Required fields
  offer_id: string
  item_id: string | null  // ‚úÖ Peut √™tre NULL maintenant
  msrp: number
  street_price: number
  promo_price: number
  purchase_price_ht: number

  // Optional fields
  purchase_currency?: string
  ean?: string
  product_name?: string
  package_weight_kg?: number
  category_id?: string       // ‚úÖ NOUVEAU
  subcategory_id?: string    // ‚úÖ NOUVEAU
  quantity?: number
  pesa_fee_ht?: number
  warranty_cost_ht?: number
}
```

**Validation mise √† jour**:
```typescript
// item_id retir√© des champs requis
const requiredFields = [
  'offer_id',
  // 'item_id',  // ‚ùå RETIR√â - peut √™tre null
  'msrp',
  'street_price',
  'promo_price',
  'purchase_price_ht'
]
```

**Construction payload**:
```typescript
const itemData = {
  offer_id: body.offer_id,
  item_id: body.item_id || null,              // Peut √™tre null
  category_id: body.category_id || null,      // ‚úÖ NOUVEAU
  subcategory_id: body.subcategory_id || null, // ‚úÖ NOUVEAU
  // ...autres champs
}
```

### 3. Fix Docker Build - Lazy Supabase Client

**Probl√®me Rencontr√©**:
```
Error: supabaseUrl is required
```
Le client Supabase √©tait initialis√© au niveau module, s'ex√©cutant au moment du build Docker quand les variables d'environnement n'existent pas.

**Solution Impl√©ment√©e**: Lazy initialization pattern

**Fichiers modifi√©s** (4 au total):
- `app/api/calculate-logistics/route.ts`
- `app/api/calculate-transport/route.ts`
- `app/api/calculate-customs/route.ts`
- `app/api/validate-item/route.ts`

**Pattern appliqu√©**:
```typescript
// AVANT (‚ùå √©choue au build)
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
const supabase = createClient(supabaseUrl, supabaseKey)

// APR√àS (‚úÖ fonctionne)
let supabaseClient: SupabaseClient | null = null

function getSupabaseClient() {
  if (!supabaseClient) {
    const isLocalDev = process.env.NODE_ENV === 'development' && !process.env.USE_PROD_SUPABASE
    const supabaseUrl = isLocalDev
      ? 'http://127.0.0.1:54331'
      : process.env.NEXT_PUBLIC_SUPABASE_URL!
    const supabaseKey = isLocalDev
      ? 'sb_publishable_ACJWlzQHlZjBrEguHvfOxg_3BJgxAaH'
      : process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

    supabaseClient = createClient(supabaseUrl, supabaseKey)
  }
  return supabaseClient
}

// Utilisation
const supabase = getSupabaseClient()
const { data, error } = await supabase.rpc('...')
```

**R√©sultat**: ‚úÖ Build Docker r√©ussi, containers d√©ploy√©s

### 4. D√©ploiement Production

**Serveur**: 31.97.193.159 (srv907289.hstgr.cloud)

**Containers d√©ploy√©s**:
- ‚úÖ `odl-tools-app` - Port 3001 - https://app.odl-tools.ch
- ‚úÖ `api-validation` - Port 3003 - https://api.odl-tools.ch

**V√©rifications effectu√©es**:
```bash
# Test endpoint documentation
curl https://api.odl-tools.ch/api/validate-item
# ‚úÖ R√©ponse OK

# Test connexion database
curl -X POST https://api.odl-tools.ch/api/validate-item \
  -H "X-API-Key: TEST" \
  -d '{...}'
# ‚úÖ Connexion Supabase fonctionnelle
```

## üìä Architecture Finale

### Flux de Donn√©es WeWeb ‚Üí API

```
WeWeb
  ‚Üì
  {
    offer_id: "uuid",
    item_id: null,              // ‚Üê NULL accept√©
    subcategory_id: "s5",       // ‚Üê ID accept√©
    msrp: 200,
    promo_price: 150,
    ...
  }
  ‚Üì
API Route (/api/validate-item)
  ‚Üì
validate_and_calculate_item(p_supplier_id, p_user_id, p_item_data)
  ‚Üì
  1. G√©n√©ration UUID si item_id NULL
  2. Lookup subcategory_id ‚Üí subcategory_name + category_name
  3. Lookup category_id pour r√®gles m√©tier
  4. Matching r√®gle m√©tier par category_id/subcategory_id
  5. Calcul COGS, marges, deal_status
  6. Insertion dans offer_item_calculated_costs
  ‚Üì
R√©ponse
  {
    success: true,
    is_valid: true,
    deal_status: "good",
    generated_item_id: "uuid-auto-gener√©",  // ‚Üê Nouveau
    ...
  }
```

### Tables Impliqu√©es

**Tables de r√©f√©rence** (source IDs):
- `odl_product_categories` (category_id ‚Üí name)
- `odl_product_subcategories` (subcategory_id ‚Üí name, category_id)
- `odl_service_categories`
- `odl_service_subcategories`

**Tables de business logic** (utilisation IDs):
- `odl_rules` (category_id, subcategory_id pour matching)
- `odeal_customs_duty_rates` (subcategory_id pour taux douane)
- `offer_item_calculated_costs` (stockage category_id + name)

**Tables transactionnelles**:
- `offer_item_calculated_costs` (un item valid√© = un record)
- `offer_financial_projections` (agr√©gation par offre)

## üîÑ Compatibilit√©

### Backward Compatibility

L'API accepte maintenant **3 formats** diff√©rents:

**Format 1: IDs uniquement** (nouveau, recommand√© pour WeWeb)
```json
{
  "offer_id": "uuid",
  "item_id": null,
  "category_id": "c1",
  "subcategory_id": "s5",
  "msrp": 200,
  ...
}
```

**Format 2: Noms uniquement** (ancien, toujours support√©)
```json
{
  "offer_id": "uuid",
  "item_id": "EAN123",
  "category_name": "Electronics",
  "subcategory_name": "Smartphones",
  "msrp": 200,
  ...
}
```

**Format 3: Mixte** (support√©)
```json
{
  "offer_id": "uuid",
  "item_id": "EAN123",
  "category_id": "c1",
  "subcategory_name": "Smartphones",  // Sera r√©solu
  "msrp": 200,
  ...
}
```

## üß™ Tests √† Effectuer

### 1. Test avec item_id NULL

```bash
curl -X POST https://api.odl-tools.ch/api/validate-item \
  -H "Content-Type: application/json" \
  -H "X-API-Key: VOTRE_CLE_PRODUCTION" \
  -d '{
    "offer_id": "1f218950-3789-4176-a883-958c593a84af",
    "item_id": null,
    "subcategory_id": "s5",
    "msrp": 200,
    "street_price": 180,
    "promo_price": 150,
    "purchase_price_ht": 100,
    "purchase_currency": "EUR"
  }'
```

**R√©sultat attendu**:
```json
{
  "success": true,
  "generated_item_id": "uuid-auto-g√©n√©r√©",  // ‚Üê √Ä r√©cup√©rer par WeWeb
  "is_valid": true,
  "deal_status": "top|good|almost|bad",
  ...
}
```

### 2. Test avec category_id

```bash
curl -X POST https://api.odl-tools.ch/api/validate-item \
  -H "Content-Type: application/json" \
  -H "X-API-Key: VOTRE_CLE_PRODUCTION" \
  -d '{
    "offer_id": "uuid",
    "item_id": "EAN123",
    "category_id": "c1",
    "subcategory_id": "s5",
    "msrp": 200,
    ...
  }'
```

### 3. Test avec donn√©es compl√®tes WeWeb

Utiliser le payload exact de WeWeb avec:
- `item_id: null`
- `subcategory_id: "s5"` (ou autre ID WeWeb)
- Tous les prix requis

## üìù Action Items pour Int√©gration WeWeb

### C√¥t√© Backend (‚úÖ Fait)
- [x] Migration NULL item_id
- [x] Migration category_id/subcategory_id
- [x] Refactorisation architecture IDs
- [x] Fix Docker build
- [x] D√©ploiement production
- [x] Tests API endpoints

### C√¥t√© WeWeb (√Ä faire)
- [ ] Cr√©er cl√© API production (`WEWEB_PRODUCTION_2025_API_KEY`)
- [ ] Tester avec item_id: null
- [ ] V√©rifier r√©cup√©ration de generated_item_id
- [ ] Valider mapping category_id/subcategory_id
- [ ] Test end-to-end formulaire WeWeb

### C√¥t√© Data
- [ ] Populate `odl_rules` avec category_id/subcategory_id
- [ ] V√©rifier donn√©es dans `odl_product_categories` et `odl_product_subcategories`
- [ ] S'assurer que les IDs WeWeb correspondent aux IDs database

## üîë Donn√©es de R√©f√©rence

### Exemple de Cat√©gories avec IDs

**Produits**:
```sql
-- odl_product_categories
category_id | name
c1          | Electronics
c2          | Computers
c3          | Audio

-- odl_product_subcategories
subcategory_id | category_id | name
s1             | c1          | Smartphones
s2             | c1          | Wearables
s3             | c2          | Laptops
s4             | c2          | Desktops
s5             | c3          | Headphones
```

**Services**:
```sql
-- odl_service_categories
category_id | name
sc1         | Installation
sc2         | Maintenance
sc3         | Repair
```

## üêõ Debugging

### V√©rifier logs containers
```bash
ssh -i ~/.ssh/claude_temp_key root@31.97.193.159
docker logs odl-tools-app --tail=100
docker logs api-validation --tail=100
```

### V√©rifier les migrations
```bash
# Liste des migrations appliqu√©es
SELECT version, name, applied_at
FROM _sqlx_migrations
ORDER BY applied_at DESC;

# V√©rifier la structure
\d offer_item_calculated_costs
\d odl_rules
```

### V√©rifier les donn√©es
```sql
-- Exemple d'item valid√©
SELECT
  item_id,
  generated_item_id,  -- ‚Üê Nouveau champ
  category_id,        -- ‚Üê Nouveau champ
  category_name,
  subcategory_id,     -- ‚Üê Nouveau champ
  subcategory_name,
  deal_status
FROM offer_item_calculated_costs
ORDER BY created_at DESC
LIMIT 5;
```

## üìö Documentation Mise √† Jour

**Fichiers modifi√©s**:
- `API_SPECIFICATION.md` - Documentation compl√®te de l'API
- Route TypeScript interfaces - Nouveaux champs
- Migration comments - Explications d√©taill√©es

## üéì Points Techniques Importants

### 1. Pourquoi Lazy Client Pattern?
Le module-level initialization s'ex√©cute au moment du build Docker, pas au runtime. Les variables d'environnement ne sont disponibles qu'au runtime du container.

### 2. Pourquoi Architecture IDs?
- **Multilingue**: Les noms peuvent changer selon la langue, les IDs sont immuables
- **Performance**: Matching par TEXT est plus lent que par ID
- **Int√©grit√©**: Foreign keys sur IDs plus fiables que sur noms

### 3. UUID Auto-g√©n√©ration
PostgreSQL `gen_random_uuid()` garantit l'unicit√© m√™me en cas de haute concurrence.

## üìû Support

**En cas de probl√®me**:
1. V√©rifier logs containers (voir section Debugging)
2. Tester endpoint avec curl
3. V√©rifier migrations appliqu√©es
4. V√©rifier donn√©es de r√©f√©rence (categories)

**Contacts**:
- Dashboard: https://app.odl-tools.ch
- API Endpoint: https://api.odl-tools.ch
- Database: Supabase projet xewnzetqvrovqjcvwkus

---

**Date**: 26 Octobre 2025
**Version API**: 1.1.0
**Status**: ‚úÖ Production Ready
**Next Step**: Tests WeWeb avec donn√©es r√©elles
